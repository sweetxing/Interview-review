## 一、存储引擎

**两种主要的引擎**

### 1.1 MyISAM(default)

**特点：**

- **表锁：**读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录
- **修复：**手工或自动执行检查和修复操作，但是不支持事务
- **索引特性：**支持全文索引，支持blob、text长字段索引

**总结：**成也表锁，败也表锁

### 1.2 InnoDB

- **行锁：** 既支持行锁也支持表锁，默认行锁
- **外键：** 支持外键
- **MVCC：** 支持多版本并发控制

### 1.3 补充知识点MVCC

1. 应对高并发事务，MVCC比单纯的加锁更高效
2. 只在READ COMMITTED和REPEATABLE READ两个隔离级别下工作
3. MVCC可以使用乐观锁和悲观锁来实现
4. InnoDB的MVCC是在每行记录保存三个隐藏的列来实现的（DB_TRX_ID只是最后一次插入或更新的事务标识符、DB_ROLL_ID、DB_ROW_ID自增行（InnoDB的隐藏列）

## 二、索引

### 2.1 索引的类型

- **B+Tree索引** （靠左列匹配）
- **哈希索引** （hash表） 

缺点：无法排序、无法根据索引列匹配查询、不支持范围查找

- **空间数据索引**

### 2.2 索引的优点

- 大大减少了服务器需要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机IO变为顺序IO

### 2.3 索引相关的面试题

#### 2.3.1 创建索引的语句

CREATE [UNIQUE] INDEX index_name ON table_name (column_list)

ALTER TABLE table_name ADD INDEX [index_name] (column_list)

#### 2.3.2 什么情况下导致索引失效

1. 如果where语句中有需要数据库动脑子的表达式
2. 对于多列索引，不使用最左列
3. like查询是以%开头
4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
5. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引

## 三、事务

### 3.1 事务的四大特性

- **原子性**  事务是最小的执行范围，不允许分割
- **一致性**  执行十五前后，数据保持一致，多个事务对同一个数据读取的结果是相同的
- **隔离性**  并发访问数据库时，一个用户的事务不被其他事物所干扰，各并发事务之间数据库是独立的
- **持久性**  一个事务被提交之后。它对数据库中的改变是持久的。

### 3.2 并发事务带来哪些问题

- **脏读**  类似于线程的可见性
- **丢失修改**  类似于线程的原子性
- **不可重复读**  指同一条数据，在较短时间间隔的两次读取，读取的结果不同；重在修改
- **幻读**  指同一张表，在较短时间间隔的两次读取，读取的记录内容不同；重在新增和删除

### 3.3 事务隔离级别

- **READ-UNCOMMITTED：**  允许读取尚未提交的数据变更
- **READ-COMMITTED：** 允许读取并发事务已经提交的数据
- **REPEATABLE-READ：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改
- **SERIALIZABLE：** 完全服从acid

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | 勾   | 勾         | 勾   |
| READ-COMMITTED   | ×    | 勾         | 勾   |
| REPEATABLE-READ  | ×    | ×          | 勾   |
| SERIALIZABLE     | ×    | ×          | ×    |

