## 一、Java内存区域与内存溢出异常

### 1.1 运行时数据区域

![img](./jvmstructure.png)

#### 1.1.1 程序计数器(私有)

**Def：** 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一跳需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

**作用：** 1.代码的流程控制 2.线程切换时恢复现场

**Notation：** 每条线程都有一个独立的线程计数器，唯一一个不会产生OutOfMemoryError 的内存区域。它与线程同生同死。

#### 1.1.2 虚拟机栈(私有)

**Def：**虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

**两种异常状况：** StackOverflowError和OutOfMemoryError

- **StackOverflowError：** 线程请求的深度大于虚拟机所允许的深度
- **OutOfMemoryError：** 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存抛出该异常。

**Notation：** 为虚拟机执行Java方法服务。

#### 1.1.3 本地方法栈(私有)

作用类似于虚拟机栈，产生的异常也同虚拟机栈

**Notation：** 为虚拟机执行Native方法服务。

#### 1.1.4 Java 堆(线程共享)

**Def：** Java堆是所有线程共享的一块内存区域，在虚拟机启动时启动。唯一目的就是存放对象实例，几乎所有的的对象实例都在这里分配内存。是Java虚拟机所管理的内存中最大的一块。

**划分：** 新生代（Eden空间、From Survivor空间、To Survivor空间）、老生代（Tentired）

**Notation：** 垃圾收集器管理的主要区域。

**唯一异常状况：** 当堆中没存内存完成实例分配，并且堆也无法再扩展时，将抛出OutOfMemoryError异常。

#### 1.1.5 方法区(线程共享)

**作用：** 存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。

**唯一异常状况：** 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

#### 1.1.6 运行时常量池(方法区的一部分)

**Class文件组成：** 类的版本、字段、方法、接口和常量池信息

<img src="./常量池包含内容.png" alt="img" style="zoom:33%;" />

**唯一异常状况：** 当常量池无法再申请到内存时，将抛出OutOfMemoryError异常。

**Notation：** Jdk1.7之后，JVM将常量池从方法去中移了出来，再Java堆中开辟了一块区域存放运行时常量池

#### 1.1.7 直接内存(非Java内存区域的一部分)

**唯一异常状况：** 当各个内存区域总和大于物理内存限制时，将抛出OutOfMemoryError异常。

