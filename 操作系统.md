## 进程和线程的区别

线程时进程划分成更小的运行单位，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响 。线程执行开销小，但不利于资源的管理和保护；而进程正相反。

## 进程的五种状态

- 创建
- 就绪
- 运行
- 阻塞
- 结束

## 进程间通信的七种方式

- **管道/匿名管道**

只能用于具有亲缘关系的父子进程间或者兄弟进程之间的**半双工通信**。

- **有名管道**

任意两个进程间的**半双工通信**。

- **信号**
- **消息队列**
- **信号量**
- **共享内存**
- **套接字**

## 线程同步的三种线程同步方式

- **互斥量（Mutex）**

采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。如Java中synchronized

- **信号量（Semphares）**

它允许同一时刻多个线程访问统一资源，但是需要控制同一时刻访问此资源的最大线程数量

- **事件（Event）**

Wait/Notify：通过通知操作的方式保持多线程同步，还可以方便的实现多线程优先级的计较

## 进程调度算法

- **先到先服务（FCFS）**
- **短作业优先（SJF）**
- **高响应比**
- **时间片轮转**
- **多级反馈队列**

前面三种算法的结合，有多个不用优先级别的队列，队列内部先到先服务，队列间时间片轮转，优先级别高的先执行，分配的时间片最短。一般是大作业优先级别低，既照顾了短作业也照顾了长进程。

- **公平共享调度算法**

## 死锁

### 死锁产生的四个必要条件

- **互斥条件**  
- **请求和保持**
- **不可剥夺**
- **环路等待**

### 哲学家进餐为例破坏死锁

- **破坏环路等待**

```c
#define   N   5                     // 哲学家个数
semaphore fork[5];                  // 信号量初值为1
void   philosopher(int   i)         // 哲学家编号：0 － 4
    while(TRUE)
    {
        think( );                   // 哲学家在思考
        if (i%2 == 0) {
            P(fork[i]);	      // 去拿左边的叉子
            P(fork[(i + 1) % N]);   // 去拿右边的叉子
        } else {
            P(fork[(i + 1) % N]);   // 去拿右边的叉子
            P(fork[i]);             // 去拿左边的叉子 
        }      
        eat( );                     // 吃面条中….
        V(fork[i]);		      // 放下左边的叉子
        V(fork[(i + 1) % N]);	      // 放下右边的叉子
    }
}
```

- **破坏请求和保持**

```c
#define   N   5                    // 哲学家个数
semaphore fork[5];                 // 信号量初值为1
semaphore   mutex;	                         // 互斥信号量，初值1
void   philosopher(int   i)               // 哲学家编号：0 － 4
    while(TRUE){
        think( );                                   // 哲学家在思考	
        P(mutex);                                   // 进入临界区	
        P(fork[i]);                               // 去拿左边的叉子
        P(fork[(i + 1) % N]);     // 去拿右边的叉子
        eat( );                                       // 吃面条中…. 	
        V(fork[i]);	                        // 放下左边的叉子
        V(fork[(i + 1) % N]);         // 放下右边的叉子
        V(mutex);                                  // 退出临界区	
    }
}
```

- **不可剥夺**

思路是利用优先级，优先级低的线程响应优先级高的中断请求，释放自己自己持有的锁

## 银行家算法（避免死锁）

明天看

